import {
  VTextField
} from "./chunk-3FXAMV7F.js";
import {
  VChip
} from "./chunk-P5VADZBY.js";
import {
  VInput,
  VLabel,
  filterInputProps,
  makeVInputProps
} from "./chunk-LHXYG3CF.js";
import {
  VList,
  VListItem,
  makeItemsProps,
  useItems
} from "./chunk-SPYHV2ZW.js";
import "./chunk-WHK3TB4I.js";
import {
  VMenu
} from "./chunk-COO53SKQ.js";
import "./chunk-EDF6XJ4Z.js";
import "./chunk-IGTRT6LU.js";
import {
  forwardRefs
} from "./chunk-LJBPEXTV.js";
import {
  useLocale
} from "./chunk-FND3FRNN.js";
import "./chunk-3JZBN47X.js";
import {
  VDialogTransition
} from "./chunk-QAGD4JHD.js";
import "./chunk-7IMRTJYR.js";
import "./chunk-4XFS4E34.js";
import {
  Ripple
} from "./chunk-H7IOOUSU.js";
import "./chunk-7DW4GNSM.js";
import {
  VDefaultsProvider
} from "./chunk-KBCBN6IQ.js";
import "./chunk-WOGKPBG3.js";
import {
  useProxiedModel
} from "./chunk-Z7H4O4HF.js";
import "./chunk-YJ6KMOY3.js";
import "./chunk-2JKRBEA4.js";
import "./chunk-TN3ACNV7.js";
import {
  makeDensityProps,
  useDensity
} from "./chunk-PFLLVXZV.js";
import {
  VIcon
} from "./chunk-XH3XVPWB.js";
import "./chunk-N5KWY5RH.js";
import "./chunk-LF3R5NEA.js";
import "./chunk-KJUB45CG.js";
import "./chunk-K4JD656G.js";
import "./chunk-MUI3WIJK.js";
import {
  useTextColor
} from "./chunk-3PEZ63GV.js";
import {
  makeTransitionProps
} from "./chunk-3IMRM6AM.js";
import "./chunk-Y6AJBS2M.js";
import {
  IconValue
} from "./chunk-OVA7IPAR.js";
import {
  makeThemeProps
} from "./chunk-EVWLYFE4.js";
import {
  SUPPORTS_FOCUS_VISIBLE,
  deepEqual,
  defineComponent,
  filterInputAttrs,
  genericComponent,
  getUid,
  pick,
  propsFactory,
  useRender,
  wrapInArray
} from "./chunk-V72RWUGP.js";
import {
  Fragment,
  computed,
  createTextVNode,
  createVNode,
  inject,
  mergeProps,
  provide,
  ref,
  resolveDirective,
  toRef,
  withDirectives
} from "./chunk-BX7HPCYS.js";
import "./chunk-RSJERJUL.js";

// node_modules/vuetify/lib/components/VSelect/VSelect.mjs
import "C:/Users/Cuenta Bisite00/Documents/BISITE/prototypeApp/prototypeApp/front/node_modules/vuetify/lib/components/VSelect/VSelect.css";

// node_modules/vuetify/lib/components/VCheckbox/VCheckbox.mjs
import "C:/Users/Cuenta Bisite00/Documents/BISITE/prototypeApp/prototypeApp/front/node_modules/vuetify/lib/components/VCheckbox/VCheckbox.css";

// node_modules/vuetify/lib/components/VSelectionControl/VSelectionControl.mjs
import "C:/Users/Cuenta Bisite00/Documents/BISITE/prototypeApp/prototypeApp/front/node_modules/vuetify/lib/components/VSelectionControl/VSelectionControl.css";

// node_modules/vuetify/lib/components/VSelectionControlGroup/VSelectionControlGroup.mjs
import "C:/Users/Cuenta Bisite00/Documents/BISITE/prototypeApp/prototypeApp/front/node_modules/vuetify/lib/components/VSelectionControlGroup/VSelectionControlGroup.css";
var VSelectionControlGroupSymbol = Symbol.for("vuetify:selection-control-group");
var VSelectionControlGroup = defineComponent({
  name: "VSelectionControlGroup",
  props: {
    disabled: Boolean,
    id: String,
    inline: Boolean,
    name: String,
    falseIcon: IconValue,
    trueIcon: IconValue,
    multiple: {
      type: Boolean,
      default: null
    },
    readonly: Boolean,
    type: String,
    modelValue: null
  },
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const modelValue = useProxiedModel(props, "modelValue");
    const uid = getUid();
    const id = computed(() => props.id || `v-selection-control-group-${uid}`);
    const name = computed(() => props.name || id.value);
    provide(VSelectionControlGroupSymbol, {
      disabled: toRef(props, "disabled"),
      inline: toRef(props, "inline"),
      modelValue,
      multiple: computed(() => !!props.multiple || props.multiple == null && Array.isArray(modelValue.value)),
      name,
      falseIcon: toRef(props, "falseIcon"),
      trueIcon: toRef(props, "trueIcon"),
      readonly: toRef(props, "readonly"),
      type: toRef(props, "type")
    });
    useRender(() => {
      var _slots$default;
      return createVNode("div", {
        "class": ["v-selection-control-group", {
          "v-selection-control-group--inline": props.inline
        }],
        "aria-labelled-by": props.type === "radio" ? id.value : void 0,
        "role": props.type === "radio" ? "radiogroup" : void 0
      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]);
    });
    return {};
  }
});

// node_modules/vuetify/lib/components/VSelectionControl/VSelectionControl.mjs
var makeSelectionControlProps = propsFactory({
  color: String,
  disabled: Boolean,
  error: Boolean,
  id: String,
  inline: Boolean,
  label: String,
  falseIcon: IconValue,
  trueIcon: IconValue,
  ripple: {
    type: Boolean,
    default: true
  },
  multiple: {
    type: Boolean,
    default: null
  },
  name: String,
  readonly: Boolean,
  trueValue: null,
  falseValue: null,
  modelValue: null,
  type: String,
  value: null,
  valueComparator: {
    type: Function,
    default: deepEqual
  },
  ...makeThemeProps(),
  ...makeDensityProps()
});
function useSelectionControl(props) {
  const group = inject(VSelectionControlGroupSymbol, void 0);
  const {
    densityClasses
  } = useDensity(props);
  const modelValue = useProxiedModel(props, "modelValue");
  const trueValue = computed(() => props.trueValue !== void 0 ? props.trueValue : props.value !== void 0 ? props.value : true);
  const falseValue = computed(() => props.falseValue !== void 0 ? props.falseValue : false);
  const isMultiple = computed(() => (group == null ? void 0 : group.multiple.value) || !!props.multiple || props.multiple == null && Array.isArray(modelValue.value));
  const model = computed({
    get() {
      const val = group ? group.modelValue.value : modelValue.value;
      return isMultiple.value ? val.some((v) => props.valueComparator(v, trueValue.value)) : props.valueComparator(val, trueValue.value);
    },
    set(val) {
      if (props.readonly)
        return;
      const currentValue = val ? trueValue.value : falseValue.value;
      let newVal = currentValue;
      if (isMultiple.value) {
        newVal = val ? [...wrapInArray(modelValue.value), currentValue] : wrapInArray(modelValue.value).filter((item) => !props.valueComparator(item, trueValue.value));
      }
      if (group) {
        group.modelValue.value = newVal;
      } else {
        modelValue.value = newVal;
      }
    }
  });
  const {
    textColorClasses,
    textColorStyles
  } = useTextColor(computed(() => {
    return model.value && !props.error && !props.disabled ? props.color : void 0;
  }));
  const icon = computed(() => {
    var _a, _b;
    return model.value ? (_a = group == null ? void 0 : group.trueIcon.value) != null ? _a : props.trueIcon : (_b = group == null ? void 0 : group.falseIcon.value) != null ? _b : props.falseIcon;
  });
  return {
    group,
    densityClasses,
    trueValue,
    falseValue,
    model,
    textColorClasses,
    textColorStyles,
    icon
  };
}
var VSelectionControl = genericComponent()({
  name: "VSelectionControl",
  directives: {
    Ripple
  },
  inheritAttrs: false,
  props: makeSelectionControlProps(),
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      densityClasses,
      group,
      icon,
      model,
      textColorClasses,
      textColorStyles,
      trueValue
    } = useSelectionControl(props);
    const uid = getUid();
    const id = computed(() => props.id || `input-${uid}`);
    const isFocused = ref(false);
    const isFocusVisible = ref(false);
    const input = ref();
    function onFocus(e) {
      isFocused.value = true;
      if (!SUPPORTS_FOCUS_VISIBLE || SUPPORTS_FOCUS_VISIBLE && e.target.matches(":focus-visible")) {
        isFocusVisible.value = true;
      }
    }
    function onBlur() {
      isFocused.value = false;
      isFocusVisible.value = false;
    }
    function onInput(e) {
      model.value = e.target.checked;
    }
    useRender(() => {
      var _a, _b;
      var _slots$default, _slots$input;
      const label = slots.label ? slots.label({
        label: props.label,
        props: {
          for: id.value
        }
      }) : props.label;
      const type = (_a = group == null ? void 0 : group.type.value) != null ? _a : props.type;
      const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
      return createVNode("div", mergeProps({
        "class": ["v-selection-control", {
          "v-selection-control--dirty": model.value,
          "v-selection-control--disabled": props.disabled,
          "v-selection-control--error": props.error,
          "v-selection-control--focused": isFocused.value,
          "v-selection-control--focus-visible": isFocusVisible.value,
          "v-selection-control--inline": (group == null ? void 0 : group.inline.value) || props.inline
        }, densityClasses.value]
      }, rootAttrs), [createVNode("div", {
        "class": ["v-selection-control__wrapper", textColorClasses.value],
        "style": textColorStyles.value
      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots), withDirectives(createVNode("div", {
        "class": ["v-selection-control__input"]
      }, [icon.value && createVNode(VIcon, {
        "key": "icon",
        "icon": icon.value
      }, null), createVNode("input", mergeProps({
        "ref": input,
        "checked": model.value,
        "disabled": props.disabled,
        "id": id.value,
        "onBlur": onBlur,
        "onFocus": onFocus,
        "onInput": onInput,
        "aria-readonly": props.readonly,
        "type": type,
        "value": trueValue.value,
        "name": (_b = group == null ? void 0 : group.name.value) != null ? _b : props.name,
        "aria-checked": type === "checkbox" ? model.value : void 0
      }, inputAttrs), null), (_slots$input = slots.input) == null ? void 0 : _slots$input.call(slots, {
        model,
        textColorClasses,
        props: {
          onFocus,
          onBlur,
          id: id.value
        }
      })]), [[resolveDirective("ripple"), props.ripple && [!props.disabled && !props.readonly, null, ["center", "circle"]]]])]), label && createVNode(VLabel, {
        "for": id.value
      }, {
        default: () => [label]
      })]);
    });
    return {
      isFocused,
      input
    };
  }
});

// node_modules/vuetify/lib/components/VCheckbox/VCheckboxBtn.mjs
var makeVCheckboxBtnProps = propsFactory({
  indeterminate: Boolean,
  indeterminateIcon: {
    type: IconValue,
    default: "$checkboxIndeterminate"
  },
  ...makeSelectionControlProps({
    falseIcon: "$checkboxOff",
    trueIcon: "$checkboxOn"
  })
});
var VCheckboxBtn = defineComponent({
  name: "VCheckboxBtn",
  props: makeVCheckboxBtnProps(),
  emits: {
    "update:modelValue": (value) => true,
    "update:indeterminate": (val) => true
  },
  setup(props, _ref) {
    let {
      slots,
      emit
    } = _ref;
    const indeterminate = useProxiedModel(props, "indeterminate");
    function onChange(v) {
      if (indeterminate.value) {
        indeterminate.value = false;
      }
      emit("update:modelValue", v);
    }
    const falseIcon = computed(() => {
      return props.indeterminate ? props.indeterminateIcon : props.falseIcon;
    });
    const trueIcon = computed(() => {
      return props.indeterminate ? props.indeterminateIcon : props.trueIcon;
    });
    useRender(() => createVNode(VSelectionControl, mergeProps(props, {
      "class": "v-checkbox-btn",
      "type": "checkbox",
      "inline": true,
      "onUpdate:modelValue": onChange,
      "falseIcon": falseIcon.value,
      "trueIcon": trueIcon.value,
      "aria-checked": props.indeterminate ? "mixed" : void 0
    }), slots));
    return {};
  }
});
function filterCheckboxBtnProps(props) {
  return pick(props, Object.keys(VCheckboxBtn.props));
}

// node_modules/vuetify/lib/components/VCheckbox/VCheckbox.mjs
var VCheckbox = defineComponent({
  name: "VCheckbox",
  inheritAttrs: false,
  props: {
    ...makeVInputProps(),
    ...makeVCheckboxBtnProps()
  },
  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const uid = getUid();
    const id = computed(() => props.id || `checkbox-${uid}`);
    useRender(() => {
      const [inputAttrs, controlAttrs] = filterInputAttrs(attrs);
      const [inputProps, _1] = filterInputProps(props);
      const [checkboxProps, _2] = filterCheckboxBtnProps(props);
      return createVNode(VInput, mergeProps({
        "class": "v-checkbox"
      }, inputAttrs, inputProps, {
        "id": id.value
      }), {
        ...slots,
        default: (_ref2) => {
          let {
            id: id2,
            isDisabled,
            isReadonly
          } = _ref2;
          return createVNode(VCheckboxBtn, mergeProps(checkboxProps, {
            "id": id2.value,
            "disabled": isDisabled.value,
            "readonly": isReadonly.value
          }, controlAttrs), slots);
        }
      });
    });
    return {};
  }
});

// node_modules/vuetify/lib/components/VSelect/VSelect.mjs
var makeSelectProps = propsFactory({
  chips: Boolean,
  closableChips: Boolean,
  eager: Boolean,
  hideNoData: Boolean,
  hideSelected: Boolean,
  menu: Boolean,
  menuIcon: {
    type: IconValue,
    default: "$dropdown"
  },
  menuProps: {
    type: Object
  },
  modelValue: {
    type: null,
    default: () => []
  },
  multiple: Boolean,
  noDataText: {
    type: String,
    default: "$vuetify.noDataText"
  },
  openOnClear: Boolean,
  readonly: Boolean,
  ...makeItemsProps({
    itemChildren: false
  })
}, "select");
var VSelect = genericComponent()({
  name: "VSelect",
  props: {
    ...makeSelectProps(),
    ...makeTransitionProps({
      transition: {
        component: VDialogTransition
      }
    })
  },
  emits: {
    "update:modelValue": (val) => true,
    "update:menu": (val) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const vTextFieldRef = ref();
    const menu = useProxiedModel(props, "menu");
    const {
      items,
      transformIn,
      transformOut
    } = useItems(props);
    const model = useProxiedModel(props, "modelValue", [], (v) => transformIn(wrapInArray(v)), (v) => {
      var _a;
      const transformed = transformOut(v);
      return props.multiple ? transformed : (_a = transformed[0]) != null ? _a : null;
    });
    const selections = computed(() => {
      return model.value.map((v) => {
        return items.value.find((item) => item.value === v.value) || v;
      });
    });
    const selected = computed(() => selections.value.map((selection) => selection.props.value));
    function onClear(e) {
      model.value = [];
      if (props.openOnClear) {
        menu.value = true;
      }
    }
    function onClickControl() {
      if (props.hideNoData && !items.value.length || props.readonly)
        return;
      menu.value = !menu.value;
    }
    function onKeydown(e) {
      if (props.readonly)
        return;
      if (["Enter", "ArrowDown", " "].includes(e.key)) {
        menu.value = true;
      }
      if (["Escape", "Tab"].includes(e.key)) {
        menu.value = false;
      }
    }
    function select(item) {
      if (props.multiple) {
        const index = selected.value.findIndex((selection) => selection === item.value);
        if (index === -1) {
          model.value = [...model.value, item];
        } else {
          const value = [...model.value];
          value.splice(index, 1);
          model.value = value;
        }
      } else {
        model.value = [item];
        menu.value = false;
      }
    }
    useRender(() => {
      const hasChips = !!(props.chips || slots.chip);
      return createVNode(VTextField, {
        "ref": vTextFieldRef,
        "modelValue": model.value.map((v) => v.props.value).join(", "),
        "onUpdate:modelValue": (v) => {
          if (v == null)
            model.value = [];
        },
        "validationValue": model.externalValue,
        "dirty": model.value.length > 0,
        "class": ["v-select", {
          "v-select--active-menu": menu.value,
          "v-select--chips": !!props.chips,
          [`v-select--${props.multiple ? "multiple" : "single"}`]: true,
          "v-select--selected": model.value.length
        }],
        "appendInnerIcon": props.menuIcon,
        "readonly": true,
        "onClick:clear": onClear,
        "onClick:control": onClickControl,
        "onBlur": () => menu.value = false,
        "onKeydown": onKeydown
      }, {
        ...slots,
        default: () => {
          var _slots$noData, _slots$prependItem, _slots$appendItem;
          return createVNode(Fragment, null, [createVNode(VMenu, mergeProps({
            "modelValue": menu.value,
            "onUpdate:modelValue": ($event) => menu.value = $event,
            "activator": "parent",
            "contentClass": "v-select__content",
            "eager": props.eager,
            "openOnClick": false,
            "closeOnContentClick": false,
            "transition": props.transition
          }, props.menuProps), {
            default: () => [createVNode(VList, {
              "selected": selected.value,
              "selectStrategy": props.multiple ? "independent" : "single-independent",
              "onMousedown": (e) => e.preventDefault()
            }, {
              default: () => {
                var _a;
                return [!items.value.length && !props.hideNoData && ((_a = (_slots$noData = slots["no-data"]) == null ? void 0 : _slots$noData.call(slots)) != null ? _a : createVNode(VListItem, {
                  "title": t(props.noDataText)
                }, null)), (_slots$prependItem = slots["prepend-item"]) == null ? void 0 : _slots$prependItem.call(slots), items.value.map((item, index) => {
                  var _a2;
                  var _slots$item;
                  return (_a2 = (_slots$item = slots.item) == null ? void 0 : _slots$item.call(slots, {
                    item,
                    index,
                    props: mergeProps(item.props, {
                      onClick: () => select(item)
                    })
                  })) != null ? _a2 : createVNode(VListItem, mergeProps({
                    "key": index
                  }, item.props, {
                    "onClick": () => select(item)
                  }), {
                    prepend: (_ref2) => {
                      let {
                        isSelected
                      } = _ref2;
                      return props.multiple && !props.hideSelected ? createVNode(VCheckboxBtn, {
                        "modelValue": isSelected,
                        "ripple": false
                      }, null) : void 0;
                    }
                  });
                }), (_slots$appendItem = slots["append-item"]) == null ? void 0 : _slots$appendItem.call(slots)];
              }
            })]
          }), selections.value.map((item, index) => {
            function onChipClose(e) {
              e.stopPropagation();
              e.preventDefault();
              select(item);
            }
            const slotProps = {
              "onClick:close": onChipClose,
              modelValue: true
            };
            return createVNode("div", {
              "key": index,
              "class": "v-select__selection"
            }, [hasChips ? createVNode(VDefaultsProvider, {
              "defaults": {
                VChip: {
                  closable: props.closableChips,
                  size: "small",
                  text: item.title
                }
              }
            }, {
              default: () => [slots.chip ? slots.chip({
                item,
                index,
                props: slotProps
              }) : createVNode(VChip, slotProps, null)]
            }) : slots.selection ? slots.selection({
              item,
              index
            }) : createVNode("span", {
              "class": "v-select__selection-text"
            }, [item.title, props.multiple && index < selections.value.length - 1 && createVNode("span", {
              "class": "v-select__selection-comma"
            }, [createTextVNode(",")])])]);
          })]);
        }
      });
    });
    return forwardRefs({
      menu,
      select
    }, vTextFieldRef);
  }
});
export {
  VSelect
};
//# sourceMappingURL=vuetify_lib_components_VSelect_index__mjs.js.map

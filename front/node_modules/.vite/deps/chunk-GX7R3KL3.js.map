{
  "version": 3,
  "sources": ["../../vuetify/src/composables/toggleScope.ts", "../../vuetify/src/composables/proxiedModel.ts"],
  "sourcesContent": ["import { effectScope, watch } from 'vue'\nimport type { EffectScope, WatchSource } from 'vue'\n\nexport function useToggleScope (source: WatchSource<boolean>, cb: () => void) {\n  let scope: EffectScope | undefined\n  watch(source, active => {\n    if (active && !scope) {\n      scope = effectScope()\n      scope.run(cb)\n    } else {\n      scope?.stop()\n      scope = undefined\n    }\n  }, { immediate: true })\n}\n", "// Utilities\nimport { computed, ref, watch } from 'vue'\nimport { getCurrentInstance, toKebabCase } from '@/util'\nimport { useToggleScope } from '@/composables/toggleScope'\n\n// Types\nimport type { Ref } from 'vue'\n\ntype InnerVal<T> = T extends any[] ? Readonly<T> : T\n\n// Composables\nexport function useProxiedModel<\n  Props extends object & { [key in Prop as `onUpdate:${Prop}`]: ((val: any) => void) | undefined },\n  Prop extends Extract<keyof Props, string>,\n  Inner = Props[Prop],\n> (\n  props: Props,\n  prop: Prop,\n  defaultValue?: Props[Prop],\n  transformIn: (value?: Props[Prop]) => Inner = (v: any) => v,\n  transformOut: (value: Inner) => Props[Prop] = (v: any) => v,\n) {\n  const vm = getCurrentInstance('useProxiedModel')\n  const internal = ref(props[prop]) as Ref<Props[Prop]>\n  const kebabProp = toKebabCase(prop)\n  const checkKebab = kebabProp !== prop\n\n  const isControlled = checkKebab\n    ? computed(() => {\n      void props[prop]\n      return !!(\n        (vm.vnode.props?.hasOwnProperty(prop) || vm.vnode.props?.hasOwnProperty(kebabProp)) &&\n        (vm.vnode.props?.hasOwnProperty(`onUpdate:${prop}`) || vm.vnode.props?.hasOwnProperty(`onUpdate:${kebabProp}`))\n      )\n    })\n    : computed(() => {\n      void props[prop]\n      return !!(vm.vnode.props?.hasOwnProperty(prop) && vm.vnode.props?.hasOwnProperty(`onUpdate:${prop}`))\n    })\n\n  useToggleScope(() => !isControlled.value, () => {\n    watch(() => props[prop], val => {\n      internal.value = val\n    })\n  })\n\n  const model = computed({\n    get (): any {\n      return transformIn(isControlled.value ? props[prop] : internal.value)\n    },\n    set (newValue) {\n      if (transformIn(isControlled.value ? props[prop] : internal.value) === newValue) {\n        return\n      }\n      newValue = transformOut(newValue)\n      internal.value = newValue\n      vm?.emit(`update:${prop}`, newValue)\n    },\n  }) as any as Ref<InnerVal<Inner>> & { readonly externalValue: Props[Prop] }\n\n  Object.defineProperty(model, 'externalValue', {\n    get: () => isControlled.value ? props[prop] : internal.value,\n  })\n\n  return model\n}\n"],
  "mappings": ";;;;;;;;;;;;AAGO,SAASA,eAAgBC,QAA8BC,IAAgB;AAC5E,MAAIC;AACJC,QAAMH,QAAQI,YAAU;AACtB,QAAIA,UAAU,CAACF,OAAO;AACpBA,cAAQG,YAAW;AACnBH,YAAMI,IAAIL,EAAV;IACD,OAAM;AAAA,UAAA;AACL,OAAA,SAAAC,UAAK,OAAL,SAAA,OAAOK,KAAP;AACAL,cAAQM;IACT;EACF,GAAE;IAAEC,WAAW;EAAb,CARE;AASN;;;ACHM,SAASC,gBAKdC,OACAC,MACAC,cAGA;AAAA,MAFAC,cAEA,UAAA,SAAA,KAAA,UAAA,OAAA,SAAA,UAAA,KAF+CC,OAAWA;AAE1D,MADAC,eACA,UAAA,SAAA,KAAA,UAAA,OAAA,SAAA,UAAA,KAD+CD,OAAWA;AAE1D,QAAME,KAAKC,mBAAmB,iBAAD;AAC7B,QAAMC,WAAWC,IAAIT,MAAMC,KAAP;AACpB,QAAMS,YAAYC,YAAYV,IAAD;AAC7B,QAAMW,aAAaF,cAAcT;AAEjC,QAAMY,eAAeD,aACjBE,SAAS,MAAM;AAAA,QAAA,iBAAA,kBAAA,kBAAA;AACf,SAAKd,MAAMC;AACX,WAAO,CAAC,IACL,kBAAAK,GAAGS,MAAMf,UAAT,QAAA,gBAAgBgB,eAAef,IAA/B,MAAA,mBAAwCK,GAAGS,MAAMf,UAAjD,QAAwC,iBAAgBgB,eAAeN,SAA/B,QACxC,mBAAAJ,GAAGS,MAAMf,UAAT,QAAA,iBAAgBgB,eAAgB,YAAWf,MAA3C,MAAA,mBAAsDK,GAAGS,MAAMf,UAA/D,QAAsD,iBAAgBgB,eAAgB,YAAWN,WAA3C;EAE1D,CANS,IAORI,SAAS,MAAM;AAAA,QAAA,kBAAA;AACf,SAAKd,MAAMC;AACX,WAAO,CAAC,GAAE,mBAAAK,GAAGS,MAAMf,UAAT,QAAA,iBAAgBgB,eAAef,IAA/B,MAAA,mBAAwCK,GAAGS,MAAMf,UAAjD,QAAwC,iBAAgBgB,eAAgB,YAAWf,MAA3C;EACnD,CAHS;AAKZgB,iBAAe,MAAM,CAACJ,aAAaK,OAAO,MAAM;AAC9CC,UAAM,MAAMnB,MAAMC,OAAOmB,SAAO;AAC9BZ,eAASU,QAAQE;IAClB,CAFI;EAGN,CAJa;AAMd,QAAMC,QAAQP,SAAS;IACrBQ,MAAY;AACV,aAAOnB,YAAYU,aAAaK,QAAQlB,MAAMC,QAAQO,SAASU,KAA7C;IACnB;IACDK,IAAKC,UAAU;AACb,UAAIrB,YAAYU,aAAaK,QAAQlB,MAAMC,QAAQO,SAASU,KAA7C,MAAwDM,UAAU;AAC/E;MACD;AACDA,iBAAWnB,aAAamB,QAAD;AACvBhB,eAASU,QAAQM;AACjBlB,YAAE,OAAF,SAAAA,GAAImB,KAAM,UAASxB,QAAQuB,QAA3B;IACD;EAXoB,CAAD;AActBE,SAAOC,eAAeN,OAAO,iBAAiB;IAC5CC,KAAK,MAAMT,aAAaK,QAAQlB,MAAMC,QAAQO,SAASU;EADX,CAA9C;AAIA,SAAOG;AACR;",
  "names": ["useToggleScope", "source", "cb", "scope", "watch", "active", "effectScope", "run", "stop", "undefined", "immediate", "useProxiedModel", "props", "prop", "defaultValue", "transformIn", "v", "transformOut", "vm", "getCurrentInstance", "internal", "ref", "kebabProp", "toKebabCase", "checkKebab", "isControlled", "computed", "vnode", "hasOwnProperty", "useToggleScope", "value", "watch", "val", "model", "get", "set", "newValue", "emit", "Object", "defineProperty"]
}

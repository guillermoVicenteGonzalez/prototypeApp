{
  "version": 3,
  "sources": ["../../vuetify/src/composables/form.ts", "../../vuetify/src/composables/forwardRefs.ts"],
  "sourcesContent": ["// Utilities\nimport { computed, inject, provide, ref, watch } from 'vue'\nimport { useProxiedModel } from '@/composables/proxiedModel'\nimport { consoleWarn, propsFactory } from '@/util'\n\n// Types\nimport type { ComputedRef, InjectionKey, PropType, Ref } from 'vue'\n\nexport interface FormProvide {\n  register: (item: {\n    id: number | string\n    validate: () => Promise<string[]>\n    reset: () => void\n    resetValidation: () => void\n  }) => void\n  unregister: (id: number | string) => void\n  update: (id: number | string, isValid: boolean | null, errorMessages: string[]) => void\n  items: Ref<FormField[]>\n  isDisabled: ComputedRef<boolean>\n  isReadonly: ComputedRef<boolean>\n  isValidating: Ref<boolean>\n}\n\ninterface FormField {\n  id: number | string\n  validate: () => Promise<string[]>\n  reset: () => void\n  resetValidation: () => void\n  isValid: boolean | null\n  errorMessages: string[]\n}\n\ninterface FieldValidationResult {\n  id: number | string\n  errorMessages: string[]\n}\n\ninterface FormValidationResult {\n  valid: boolean\n  errors: FieldValidationResult[]\n}\n\nexport interface SubmitEventPromise extends SubmitEvent, Promise<FormValidationResult> {}\n\nexport const FormKey: InjectionKey<FormProvide> = Symbol.for('vuetify:form')\n\nexport interface FormProps {\n  disabled: boolean\n  fastFail: boolean\n  lazyValidation: boolean\n  readonly: boolean\n  modelValue: boolean | null\n  'onUpdate:modelValue': ((val: boolean | null) => void) | undefined\n}\n\nexport const makeFormProps = propsFactory({\n  disabled: Boolean,\n  fastFail: Boolean,\n  lazyValidation: Boolean,\n  readonly: Boolean,\n  modelValue: {\n    type: Boolean as PropType<boolean | null>,\n    default: null,\n  },\n})\n\nexport function createForm (props: FormProps) {\n  const model = useProxiedModel(props, 'modelValue')\n\n  const isDisabled = computed(() => props.disabled)\n  const isReadonly = computed(() => props.readonly)\n  const isValidating = ref(false)\n  const items = ref<FormField[]>([])\n  const errors = ref<FieldValidationResult[]>([])\n\n  async function validate () {\n    const results = []\n    let valid = true\n\n    errors.value = []\n    isValidating.value = true\n\n    for (const item of items.value) {\n      const itemErrorMessages = await item.validate()\n\n      if (itemErrorMessages.length > 0) {\n        valid = false\n\n        results.push({\n          id: item.id,\n          errorMessages: itemErrorMessages,\n        })\n      }\n\n      if (!valid && props.fastFail) break\n    }\n\n    errors.value = results\n    isValidating.value = false\n\n    return { valid, errors: errors.value }\n  }\n\n  function reset () {\n    items.value.forEach(item => item.reset())\n    model.value = null\n  }\n\n  function resetValidation () {\n    items.value.forEach(item => item.resetValidation())\n    errors.value = []\n    model.value = null\n  }\n\n  watch(items, () => {\n    let valid = 0\n    let invalid = 0\n    const results = []\n\n    for (const item of items.value) {\n      if (item.isValid === false) {\n        invalid++\n        results.push({\n          id: item.id,\n          errorMessages: item.errorMessages,\n        })\n      } else if (item.isValid === true) valid++\n    }\n\n    errors.value = results\n    model.value =\n      invalid > 0 ? false\n      : valid === items.value.length ? true\n      : null\n  }, { deep: true })\n\n  provide(FormKey, {\n    register: ({ id, validate, reset, resetValidation }) => {\n      if (items.value.some(item => item.id === id)) {\n        consoleWarn(`Duplicate input name \"${id}\"`)\n      }\n\n      items.value.push({\n        id,\n        validate,\n        reset,\n        resetValidation,\n        isValid: null,\n        errorMessages: [],\n      })\n    },\n    unregister: id => {\n      items.value = items.value.filter(item => {\n        return item.id !== id\n      })\n    },\n    update: (id, isValid, errorMessages) => {\n      const found = items.value.find(item => item.id === id)\n\n      if (!found) return\n\n      found.isValid = isValid\n      found.errorMessages = errorMessages\n    },\n    isDisabled,\n    isReadonly,\n    isValidating,\n    items,\n  })\n\n  return {\n    errors,\n    isDisabled,\n    isReadonly,\n    isValidating,\n    items,\n    validate,\n    reset,\n    resetValidation,\n  }\n}\n\nexport function useForm () {\n  return inject(FormKey, null)\n}\n", "import type { ComponentPublicInstance, Ref, UnwrapRef } from 'vue'\nimport type { UnionToIntersection } from '@/util'\n\nconst Refs = Symbol('Forwarded refs')\n\n/** Omit properties starting with P */\ntype OmitPrefix<T, P extends string> = Omit<T, keyof T extends `${P}${any}` ? keyof T : never>\n\nexport function forwardRefs<T extends {}, U extends Ref<HTMLElement | Omit<ComponentPublicInstance, '$emit'> | undefined>[]> (\n  target: T,\n  ...refs: U\n): T & OmitPrefix<UnwrapRef<UnionToIntersection<U[number]>>, '$'> {\n  (target as any)[Refs] = refs\n\n  return new Proxy(target, {\n    get (target, key) {\n      if (Reflect.has(target, key)) {\n        return Reflect.get(target, key)\n      }\n      for (const ref of refs) {\n        if (ref.value && Reflect.has(ref.value, key)) {\n          const val = Reflect.get(ref.value, key)\n          return typeof val === 'function'\n            ? val.bind(ref.value)\n            : val\n        }\n      }\n    },\n    getOwnPropertyDescriptor (target, key) {\n      const descriptor = Reflect.getOwnPropertyDescriptor(target, key)\n      if (descriptor) return descriptor\n\n      // Skip internal properties\n      if (typeof key === 'symbol' || key.startsWith('__')) return\n\n      // Check each ref's own properties\n      for (const ref of refs) {\n        if (!ref.value) continue\n        const descriptor = Reflect.getOwnPropertyDescriptor(ref.value, key)\n        if (descriptor) return descriptor\n        if ('_' in ref.value && 'setupState' in ref.value._) {\n          const descriptor = Reflect.getOwnPropertyDescriptor(ref.value._.setupState, key)\n          if (descriptor) return descriptor\n        }\n      }\n      // Recursive search up each ref's prototype\n      for (const ref of refs) {\n        let obj = ref.value && Object.getPrototypeOf(ref.value)\n        while (obj) {\n          const descriptor = Reflect.getOwnPropertyDescriptor(obj, key)\n          if (descriptor) return descriptor\n          obj = Object.getPrototypeOf(obj)\n        }\n      }\n      // Call forwarded refs' proxies\n      for (const ref of refs) {\n        const childRefs = ref.value && (ref.value as any)[Refs]\n        if (!childRefs) continue\n        const queue = childRefs.slice()\n        while (queue.length) {\n          const ref = queue.shift()\n          const descriptor = Reflect.getOwnPropertyDescriptor(ref.value, key)\n          if (descriptor) return descriptor\n          const childRefs = ref.value && (ref.value as any)[Refs]\n          if (childRefs) queue.push(...childRefs)\n        }\n      }\n      return undefined\n    },\n  }) as any\n}\n"],
  "mappings": "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",
  "names": ["FormKey", "Symbol", "for", "makeFormProps", "propsFactory", "disabled", "Boolean", "fastFail", "lazyValidation", "readonly", "modelValue", "type", "default", "createForm", "props", "model", "useProxiedModel", "isDisabled", "computed", "isReadonly", "isValidating", "ref", "items", "errors", "validate", "results", "valid", "value", "item", "itemErrorMessages", "length", "push", "id", "errorMessages", "reset", "forEach", "resetValidation", "watch", "invalid", "isValid", "deep", "provide", "register", "some", "consoleWarn", "unregister", "filter", "update", "found", "find", "useForm", "inject", "Refs", "Symbol", "forwardRefs", "target", "refs", "Proxy", "get", "key", "Reflect", "has", "ref", "value", "val", "bind", "getOwnPropertyDescriptor", "descriptor", "startsWith", "_", "setupState", "obj", "Object", "getPrototypeOf", "childRefs", "queue", "slice", "length", "shift", "push", "undefined"]
}
